#!/usr/bin/env bash

# Worktree CLI - Git worktree management tool
# Usage: source this script or use with eval "$(worktree ...)"

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

error() {
  echo -e "${RED}Error:${NC} $1" >&2
  return 1
}

success() {
  echo -e "${GREEN}$1${NC}" >&2
}

warn() {
  echo -e "${YELLOW}$1${NC}" >&2
}

# Check if running in kitty terminal
is_kitty() {
  [[ -n "${KITTY_WINDOW_ID:-}" ]]
}

# Get repository name from a worktree path
get_repo_name() {
  local path="$1"
  local git_root parent_dir

  # Get git root from the path
  git_root="$(git -C "$path" rev-parse --show-toplevel 2>/dev/null)" || git_root="$path"
  parent_dir="$(dirname "$git_root")"

  # If inside worktrees folder, find the main worktree name
  if [[ "$(basename "$parent_dir")" == "worktrees" ]]; then
    # The main repo should be a sibling of the worktrees folder
    # or we can get it from git worktree list (first entry is usually main)
    local main_path
    main_path="$(git -C "$path" worktree list 2>/dev/null | head -1 | awk '{print $1}')"
    if [[ -n "$main_path" ]]; then
      basename "$main_path"
    else
      # Fallback: parent of worktrees folder might have the repo
      basename "$(dirname "$parent_dir")"
    fi
  else
    basename "$git_root"
  fi
}

# Open new kitty OS window with title and optional command
kitty_open_window() {
  local title="$1"
  local cwd="$2"
  shift 2
  local cmd=("$@")

  if [[ ${#cmd[@]} -eq 0 ]]; then
    ( setsid kitty --title "$title" --directory "$cwd" &>/dev/null & )
  else
    ( setsid kitty --title "$title" --directory "$cwd" "${cmd[@]}" &>/dev/null & )
  fi
  sleep 0.1
}

# Get git repo root or return error
get_repo_root() {
  git rev-parse --show-toplevel 2>/dev/null || {
    error "Not inside a git repository"
    return 1
  }
}

# Get worktrees base directory
get_worktrees_dir() {
  local repo_root="$1"
  local parent_dir
  parent_dir="$(dirname "$repo_root")"

  # Check if we're already inside a worktrees folder
  if [[ "$(basename "$parent_dir")" == "worktrees" ]]; then
    echo "$parent_dir"
  else
    echo "$parent_dir/worktrees"
  fi
}

# Extract short branch name (part after last /)
get_short_branch_name() {
  local branch="$1"
  echo "${branch##*/}"
}

# Get list of branches for completion (local first, then remote without duplicates)
get_branches() {
  local branches=()
  local local_branches
  local remote_branches

  # Get local branches
  local_branches=$(git branch --format='%(refname:short)' 2>/dev/null)

  # Get remote branches, excluding those that have local counterparts
  remote_branches=$(git branch -r --format='%(refname:short)' 2>/dev/null | sed 's|^[^/]*/||' | sort -u)

  # Add local branches first
  while IFS= read -r branch; do
    [[ -n "$branch" ]] && branches+=("$branch")
  done <<<"$local_branches"

  # Add remote branches that don't exist locally
  while IFS= read -r branch; do
    if [[ -n "$branch" ]] && ! printf '%s\n' "${branches[@]}" | grep -qx "$branch"; then
      branches+=("$branch")
    fi
  done <<<"$remote_branches"

  # Filter out branches already checked out in worktrees
  local worktree_branches
  worktree_branches=$(git worktree list --porcelain 2>/dev/null | grep '^branch ' | sed 's|^branch refs/heads/||')
  if [[ -n "$worktree_branches" ]]; then
    printf '%s\n' "${branches[@]}" | grep -vxF "$worktree_branches"
  else
    printf '%s\n' "${branches[@]}"
  fi
}

# Get list of worktrees for completion (excludes main worktree)
get_worktrees() {
  git worktree list --porcelain 2>/dev/null | grep '^worktree ' | sed 's|^worktree ||' | while read -r path; do
    # Only include worktrees inside a "worktrees" folder
    local parent_name
    parent_name="$(basename "$(dirname "$path")")"
    if [[ "$parent_name" == "worktrees" ]]; then
      basename "$path"
    fi
  done
}

# Check if branch is already checked out in a worktree
find_branch_worktree() {
  local branch="$1"
  git worktree list --porcelain 2>/dev/null | awk -v branch="$branch" '
        /^worktree / { path = substr($0, 10) }
        /^branch / { if (substr($0, 8) == "refs/heads/" branch) print path }
    '
}

# Command: create [BRANCH_NAME] [-o COMMAND] [-p PATH]
cmd_create() {
  local branch_name=""
  local command="${EDITOR:-vim}"
  local path_arg="."
  local repo_root worktrees_dir short_name worktree_path existing_worktree

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -o)
      command="$2"
      shift 2
      ;;
    -p)
      path_arg="$2"
      shift 2
      ;;
    *)
      if [[ -z "$branch_name" ]]; then
        branch_name="$1"
      fi
      shift
      ;;
    esac
  done

  # Step 1: Check if in git repo and get root
  repo_root="$(get_repo_root)" || return 1

  # Step 2: Determine branch name (use current if not provided)
  if [[ -z "$branch_name" ]]; then
    branch_name="$(git rev-parse --abbrev-ref HEAD)"
  fi

  # Step 3: Check if branch is already checked out somewhere
  existing_worktree="$(find_branch_worktree "$branch_name")"
  if [[ -n "$existing_worktree" ]]; then
    warn "Branch '$branch_name' already checked out at: $existing_worktree"
    worktree_path="$existing_worktree"
  else
    # Step 4: Get/create worktrees directory
    worktrees_dir="$(get_worktrees_dir "$repo_root")"
    if [[ ! -d "$worktrees_dir" ]]; then
      mkdir -p "$worktrees_dir"
      success "Created worktrees directory: $worktrees_dir"
    fi

    # Step 5: Determine worktree folder name and path
    short_name="$(get_short_branch_name "$branch_name")"
    worktree_path="$worktrees_dir/$short_name"

    # Step 6: Create or checkout worktree
    if [[ -d "$worktree_path" ]]; then
      # Folder exists, check if it's already a worktree
      if git worktree list | grep -q "$worktree_path"; then
        warn "Worktree already exists at $worktree_path"
        # Checkout the branch in existing worktree
        git -C "$worktree_path" checkout "$branch_name" 2>/dev/null || true
      else
        error "Directory exists but is not a worktree: $worktree_path"
        return 1
      fi
    else
      # Create new worktree
      # Check if branch exists locally
      if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        git worktree add "$worktree_path" "$branch_name" >&2
      # Check if branch exists on remote
      elif git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        git worktree add "$worktree_path" "$branch_name" >&2
      else
        # Create new branch
        git worktree add -b "$branch_name" "$worktree_path" >&2
      fi
      success "Created worktree for '$branch_name' at $worktree_path"
    fi
  fi

  # Step 7: Open worktree with command
  short_name="$(get_short_branch_name "$branch_name")"
  local target_path cmd_arg cwd

  if [[ "$path_arg" == "." ]]; then
    target_path="$worktree_path"
  else
    target_path="$worktree_path/$path_arg"
  fi

  if [[ -d "$target_path" ]]; then
    cwd="$target_path"
    cmd_arg="."
  else
    cwd="$worktree_path"
    cmd_arg="$path_arg"
  fi

  # Kitty: open in new OS window
  if is_kitty; then
    local repo_name window_title
    repo_name="$(get_repo_name "$repo_root")"
    window_title="$repo_name: $short_name"
    kitty_open_window "$window_title" "$cwd" "$command" "$cmd_arg"
    success "Opened worktree in new kitty window: $window_title"
    return 0
  fi

  # Default: output command for shell to eval
  echo "cd '$cwd' && $command '$cmd_arg'"
}

# Command: open [WORKTREE_NAME] [-o COMMAND] [-p PATH]
cmd_open() {
  local worktree_name=""
  local command="${EDITOR:-vim}"
  local path_arg="."
  local worktrees_dir worktree_path target_path repo_name window_title

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -o)
      command="$2"
      shift 2
      ;;
    -p)
      path_arg="$2"
      shift 2
      ;;
    *)
      if [[ -z "$worktree_name" ]]; then
        worktree_name="$1"
      fi
      shift
      ;;
    esac
  done

  if [[ -z "$worktree_name" ]]; then
    error "Worktree name required"
    return 1
  fi

  # Find worktree path
  worktree_path=$(git worktree list --porcelain 2>/dev/null | grep '^worktree ' | sed 's|^worktree ||' | while read -r p; do
    if [[ "$(basename "$p")" == "$worktree_name" ]]; then
      echo "$p"
      break
    fi
  done)

  if [[ -z "$worktree_path" ]]; then
    error "Worktree '$worktree_name' not found"
    return 1
  fi

  # Determine target path and command argument
  local cmd_arg cwd

  if [[ "$path_arg" == "." ]]; then
    target_path="$worktree_path"
  else
    target_path="$worktree_path/$path_arg"
  fi

  if [[ -d "$target_path" ]]; then
    # It's a directory - cd there and use "." as argument
    cwd="$target_path"
    cmd_arg="."
  else
    # It's a file (existing or new) - cd to worktree and use path as argument
    cwd="$worktree_path"
    cmd_arg="$path_arg"
  fi

  # Kitty: open in new OS window
  if is_kitty; then
    repo_name="$(get_repo_name "$worktree_path")"
    window_title="$repo_name: $worktree_name"
    kitty_open_window "$window_title" "$cwd" "$command" "$cmd_arg"
    success "Opened '$worktree_name' in new kitty window: $window_title"
    return 0
  fi

  # Default: output command for shell to eval
  echo "cd '$cwd' && $command '$cmd_arg'"
}

# Find worktree path by name
find_worktree_path() {
  local worktree_name="$1"
  git worktree list --porcelain 2>/dev/null | grep '^worktree ' | sed 's|^worktree ||' | while read -r p; do
    if [[ "$(basename "$p")" == "$worktree_name" ]]; then
      echo "$p"
      break
    fi
  done
}

# Get branch name for a worktree
get_worktree_branch() {
  local worktree_path="$1"
  git -C "$worktree_path" rev-parse --abbrev-ref HEAD 2>/dev/null
}

# Get main worktree path (original repo, not in worktrees folder)
get_main_worktree() {
  git worktree list --porcelain 2>/dev/null | grep '^worktree ' | sed 's|^worktree ||' | while read -r p; do
    local parent_name
    parent_name="$(basename "$(dirname "$p")")"
    if [[ "$parent_name" != "worktrees" ]]; then
      echo "$p"
      break
    fi
  done
}

# Check if current directory is a non-main worktree (parent dir is "worktrees/")
is_non_main_worktree() {
  local repo_root
  repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
  [[ "$(basename "$(dirname "$repo_root")")" == "worktrees" ]]
}

# Get Claude project directory for a given path
get_claude_project_dir() {
  local path="$1"
  local encoded
  encoded=$(echo "$path" | tr '/.' '-')
  echo "$HOME/.claude/projects/$encoded"
}

# Get Claude sessions from main worktree's project dir
# Output: session_id\tDescription
get_claude_sessions() {
  local main_worktree
  main_worktree="$(get_main_worktree)"
  [[ -z "$main_worktree" ]] && return 0

  local main_project_dir
  main_project_dir="$(get_claude_project_dir "$main_worktree")"
  [[ ! -d "$main_project_dir" ]] && return 0

  local index_file="$main_project_dir/sessions-index.json"

  if [[ -f "$index_file" ]] && command -v jq &>/dev/null; then
    jq -r '.entries[]? | [.sessionId, (.summary // .firstPrompt // "no description")] | @tsv' "$index_file" 2>/dev/null
  else
    # Fallback: list .jsonl files
    local f
    for f in "$main_project_dir"/*.jsonl; do
      [[ -f "$f" ]] || continue
      local sid
      sid="$(basename "$f" .jsonl)"
      printf '%s\t%s\n' "$sid" "(no description)"
    done
  fi
}

# Get Claude sessions filtered (exclude already copied ones)
get_claude_sessions_filtered() {
  local repo_root
  repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 0
  local current_project_dir
  current_project_dir="$(get_claude_project_dir "$repo_root")"

  get_claude_sessions | while IFS=$'\t' read -r sid desc; do
    [[ -z "$sid" ]] && continue
    # Skip if already exists in current worktree's project dir
    if [[ -f "$current_project_dir/$sid.jsonl" ]]; then
      continue
    fi
    printf '%s\t%s\n' "$sid" "$desc"
  done
}

# Command: delete [WORKTREE_NAME]
cmd_delete() {
  local worktree_name="${1:-}"
  local worktree_path

  if [[ -z "$worktree_name" ]]; then
    error "Worktree name required"
    return 1
  fi

  # Find worktree path
  worktree_path="$(find_worktree_path "$worktree_name")"

  if [[ -z "$worktree_path" ]]; then
    error "Worktree '$worktree_name' not found"
    return 1
  fi

  # Check for uncommitted changes
  local changes
  changes="$(git -C "$worktree_path" status --porcelain 2>/dev/null)"

  if [[ -n "$changes" ]]; then
    warn "Worktree '$worktree_name' has uncommitted changes:"
    echo "$changes" | head -10 >&2
    [[ $(echo "$changes" | wc -l) -gt 10 ]] && echo "  ..." >&2

    # Ask for confirmation
    echo -n "Delete anyway? [y/N] " >&2
    read -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo "Cancelled" >&2
      return 1
    fi
  fi

  # Get branch name before deletion
  local branch_name
  branch_name="$(get_worktree_branch "$worktree_path")"

  # Delete worktree
  git worktree remove --force "$worktree_path" >&2 || {
    error "Failed to remove worktree"
    return 1
  }

  success "Deleted worktree '$worktree_name'"

  # Optionally delete the branch if it was created for this worktree
  if [[ -n "$branch_name" && "$branch_name" != "HEAD" ]]; then
    echo -n "Also delete branch '$branch_name'? [y/N] " >&2
    read -r confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
      git branch -D "$branch_name" >&2 && success "Deleted branch '$branch_name'"
    fi
  fi
}

# Command: checkout [WORKTREE_NAME]
cmd_checkout() {
  local worktree_name="${1:-}"
  local worktree_path branch_name main_worktree

  if [[ -z "$worktree_name" ]]; then
    error "Worktree name required"
    return 1
  fi

  # Find worktree path
  worktree_path="$(find_worktree_path "$worktree_name")"

  if [[ -z "$worktree_path" ]]; then
    error "Worktree '$worktree_name' not found"
    return 1
  fi

  # Get branch name
  branch_name="$(get_worktree_branch "$worktree_path")"
  if [[ -z "$branch_name" || "$branch_name" == "HEAD" ]]; then
    error "Could not determine branch for worktree '$worktree_name'"
    return 1
  fi

  # Get main worktree
  main_worktree="$(get_main_worktree)"
  if [[ -z "$main_worktree" ]]; then
    error "Could not find main worktree"
    return 1
  fi

  # Check for uncommitted changes in worktree
  local changes
  changes="$(git -C "$worktree_path" status --porcelain 2>/dev/null)"

  if [[ -n "$changes" ]]; then
    warn "Worktree '$worktree_name' has uncommitted changes:"
    echo "$changes" | head -10 >&2
    [[ $(echo "$changes" | wc -l) -gt 10 ]] && echo "  ..." >&2

    echo -n "Delete worktree and checkout branch in main repo anyway? [y/N] " >&2
    read -r confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
      echo "Cancelled" >&2
      return 1
    fi
  fi

  # Delete worktree
  git worktree remove --force "$worktree_path" >&2 || {
    error "Failed to remove worktree"
    return 1
  }
  success "Deleted worktree '$worktree_name'"

  # Checkout branch in main worktree
  git -C "$main_worktree" checkout "$branch_name" >&2 || {
    error "Failed to checkout branch '$branch_name' in main worktree"
    return 1
  }
  success "Checked out '$branch_name' in main worktree"

  # Output cd command to main worktree
  echo "cd '$main_worktree'"
}

# Command: claude copy-session [SESSION_ID]
cmd_claude_copy_session() {
  local session_id="${1:-}"

  if [[ -z "$session_id" ]]; then
    error "Session ID required"
    return 1
  fi

  # Guard: must be in a non-main worktree
  if ! is_non_main_worktree; then
    error "Must be in a non-main worktree"
    return 1
  fi

  # Resolve paths
  local main_worktree
  main_worktree="$(get_main_worktree)"
  [[ -z "$main_worktree" ]] && { error "Could not find main worktree"; return 1; }

  local repo_root
  repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || { error "Not in a git repo"; return 1; }

  local src_dir dst_dir
  src_dir="$(get_claude_project_dir "$main_worktree")"
  dst_dir="$(get_claude_project_dir "$repo_root")"

  # Validate source session exists
  if [[ ! -f "$src_dir/$session_id.jsonl" ]]; then
    error "Session '$session_id' not found in $src_dir"
    return 1
  fi

  # Check if already copied
  if [[ -f "$dst_dir/$session_id.jsonl" ]]; then
    warn "Session '$session_id' already exists in target project dir"
    return 0
  fi

  # Create target directory
  mkdir -p "$dst_dir"

  # Copy session file, rewriting cwd to point to current worktree
  # Each JSONL entry contains a "cwd" field that Claude Code uses to match sessions to projects
  sed "s|\"cwd\":\"$main_worktree\"|\"cwd\":\"$repo_root\"|g; s|\"cwd\": \"$main_worktree\"|\"cwd\": \"$repo_root\"|g" \
    "$src_dir/$session_id.jsonl" > "$dst_dir/$session_id.jsonl"

  # Copy session directory if it exists
  if [[ -d "$src_dir/$session_id" ]]; then
    cp -r "$src_dir/$session_id" "$dst_dir/$session_id"
  fi

  # Update target sessions-index.json
  if command -v jq &>/dev/null && [[ -f "$src_dir/sessions-index.json" ]]; then
    local entry
    entry=$(jq --arg sid "$session_id" '.entries[]? | select(.sessionId == $sid)' "$src_dir/sessions-index.json" 2>/dev/null)

    if [[ -n "$entry" ]]; then
      # Update fullPath (path to .jsonl file) and projectPath (project root)
      entry=$(echo "$entry" | jq \
        --arg fp "$dst_dir/$session_id.jsonl" \
        --arg pp "$repo_root" \
        '.fullPath = $fp | .projectPath = $pp')

      if [[ -f "$dst_dir/sessions-index.json" ]]; then
        # Append entry if not duplicate
        local updated
        updated=$(jq --arg sid "$session_id" --argjson entry "$entry" \
          'if (.entries | map(.sessionId) | index($sid)) then . else .entries += [$entry] end' \
          "$dst_dir/sessions-index.json" 2>/dev/null)
        echo "$updated" > "$dst_dir/sessions-index.json"
      else
        # Create new index
        jq -n --argjson entry "$entry" '{version: 1, entries: [$entry]}' > "$dst_dir/sessions-index.json"
      fi
    fi
  fi

  success "Copied session '$session_id' to $dst_dir"
}

# Generate completions
generate_completions() {
  local cmd="$1"

  case "$cmd" in
  create)
    get_branches
    ;;
  claude)
    is_non_main_worktree && get_claude_sessions_filtered
    ;;
  open | delete | checkout | *)
    get_worktrees
    ;;
  esac
}

# Main entry point
main() {
  local cmd="${1:-}"

  case "$cmd" in
  create)
    shift
    cmd_create "$@"
    ;;
  open)
    shift
    cmd_open "$@"
    ;;
  delete)
    shift
    cmd_delete "$@"
    ;;
  checkout)
    shift
    cmd_checkout "$@"
    ;;
  claude)
    shift
    local subcmd="${1:-}"
    case "$subcmd" in
    copy-session)
      shift
      cmd_claude_copy_session "$@"
      ;;
    *)
      error "Unknown claude subcommand: $subcmd (available: copy-session)"
      ;;
    esac
    ;;
  --complete)
    shift
    generate_completions "$@"
    ;;
  --help | -h | "")
    cat <<EOF
Worktree CLI - Git worktree management tool

Usage:
    worktree create [BRANCH] [-o CMD] [-p PATH]  Create worktree and open with command
    worktree open [NAME] [-o CMD] [-p PATH]      Open existing worktree with command
    worktree delete [NAME]                       Delete worktree (asks if uncommitted changes)
    worktree checkout [NAME]                     Delete worktree and checkout branch in main repo
    worktree claude copy-session [ID]            Copy Claude session from main worktree
    worktree [CMD] [NAME] [-p PATH]              Shortcut for: worktree open -o CMD

Options:
    -o COMMAND    Command to run (default: \$EDITOR or vim)
    -p PATH       Relative path within worktree

Examples:
    eval "\$(worktree create feature/new-thing)"
    eval "\$(worktree open main)"
    eval "\$(worktree nvim main -p src/)"
    eval "\$(worktree code feature)"
    worktree delete feature
    eval "\$(worktree checkout feature)"

Note: Use with 'eval' to change directory in current shell.

Kitty Integration:
    When running in kitty terminal, creates/opens worktrees in a new
    OS window with title "{repo}: {worktree}".
EOF
    ;;
  *)
    # Treat as shortcut: worktree [COMMAND] [NAME] [-p PATH]
    # becomes: worktree open [NAME] -o [COMMAND] [-p PATH]
    local shortcut_cmd="$cmd"
    shift
    cmd_open "$@" -o "$shortcut_cmd"
    ;;
  esac
}

main "$@"
