#!/usr/bin/env bash

# Worktree TUI - Interactive interface for worktree management
# Uses fzf for mode switching and selection

set -euo pipefail

# Get script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKTREE_CMD="$SCRIPT_DIR/worktree"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# Check if current directory is a non-main worktree
is_non_main_worktree_tui() {
    local repo_root
    repo_root="$(git rev-parse --show-toplevel 2>/dev/null)" || return 1
    [[ "$(basename "$(dirname "$repo_root")")" == "worktrees" ]]
}

# Mode definitions
MODES=("create" "open" "checkout" "delete")
MODE_LABELS=("CREATE" "OPEN" "CHECKOUT" "DELETE")

# Add CLAUDE mode if in a non-main worktree
if is_non_main_worktree_tui; then
    MODES+=("claude")
    MODE_LABELS+=("CLAUDE")
fi

# Opener definitions (shown in create and open modes)
OPENERS=("claude" "nvim" "zsh" "lazygit")

# Check if mode supports opener selection
mode_has_opener() {
    [[ "$1" == "create" || "$1" == "open" ]]
}

error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

# Check dependencies
check_deps() {
    if ! command -v fzf &>/dev/null; then
        error "fzf is required but not installed. Install with: pacman -S fzf"
    fi

    if ! git rev-parse --is-inside-work-tree &>/dev/null 2>&1; then
        error "Not inside a git repository"
    fi
}

# Get data based on mode
get_data() {
    local mode="$1"
    case "$mode" in
        create)
            "$WORKTREE_CMD" --complete create
            ;;
        claude)
            "$WORKTREE_CMD" --complete claude
            ;;
        open|checkout|delete)
            "$WORKTREE_CMD" --complete open
            ;;
    esac
}

# Build opener selector line for the header
build_opener_header() {
    local current_idx="$1"
    local line="  "

    for i in "${!OPENERS[@]}"; do
        local label="${OPENERS[$i]}"

        if [[ $i -eq $current_idx ]]; then
            line+="[${label}]"
        else
            line+=" ${label} "
        fi

        if [[ $i -lt $((${#OPENERS[@]} - 1)) ]]; then
            line+=" | "
        fi
    done

    echo "$line"
}

# Build header showing mode tabs
build_header() {
    local current_mode="$1"
    local header=""

    for i in "${!MODES[@]}"; do
        local mode="${MODES[$i]}"
        local label="${MODE_LABELS[$i]}"

        if [[ "$mode" == "$current_mode" ]]; then
            header+="[${label}]"
        else
            header+=" ${label} "
        fi

        if [[ $i -lt $((${#MODES[@]} - 1)) ]]; then
            header+=" â”‚ "
        fi
    done

    echo "$header"
}

# Get mode index
get_mode_index() {
    local mode="$1"
    for i in "${!MODES[@]}"; do
        if [[ "${MODES[$i]}" == "$mode" ]]; then
            echo "$i"
            return
        fi
    done
    echo "0"
}

# Switch to next/previous mode
switch_mode() {
    local current="$1"
    local direction="$2"
    local idx
    idx=$(get_mode_index "$current")
    local num_modes=${#MODES[@]}

    if [[ "$direction" == "right" ]]; then
        idx=$(( (idx + 1) % num_modes ))
    else
        idx=$(( (idx - 1 + num_modes) % num_modes ))
    fi

    echo "${MODES[$idx]}"
}

# Switch to next/previous opener
switch_opener() {
    local current_idx="$1"
    local direction="$2"
    local num_openers=${#OPENERS[@]}

    if [[ "$direction" == "right" ]]; then
        echo $(( (current_idx + 1) % num_openers ))
    else
        echo $(( (current_idx - 1 + num_openers) % num_openers ))
    fi
}

# Get prompt based on mode
get_prompt() {
    local mode="$1"
    case "$mode" in
        create)
            echo "Branch/New: "
            ;;
        open)
            echo "Open: "
            ;;
        checkout)
            echo "Checkout: "
            ;;
        delete)
            echo "Delete: "
            ;;
        claude)
            echo "Copy session: "
            ;;
    esac
}

# Get fzf options based on mode
get_fzf_bind() {
    local mode="$1"
    # For create mode, allow accepting typed query if no match
    if [[ "$mode" == "create" ]]; then
        echo "enter:accept-or-print-query"
    else
        echo "enter:accept"
    fi
}

# Check if any worktrees exist
has_worktrees() {
    local worktrees
    worktrees=$("$WORKTREE_CMD" --complete open)
    [[ -n "$worktrees" ]]
}

# Run fzf for selection
run_fzf() {
    local mode="$1"
    local data="$2"
    local opener_idx="${3:--1}"
    local header
    header=$(build_header "$mode")
    local prompt
    prompt=$(get_prompt "$mode")
    local bind
    bind=$(get_fzf_bind "$mode")

    local fzf_opts=(
        --prompt="$prompt"
        --header="$header"
        --header-first
        --expect="left,right,alt-h,alt-l,ctrl-left,ctrl-right,ctrl-alt-l,ctrl-alt-backspace,esc"
        --bind="$bind"
        --bind="alt-j:down,alt-k:up"
        --no-info
        --layout=reverse
        --height=~50%
        --border=rounded
        --margin=1,2
        --padding=1
        --print-query
    )

    # Show opener selector below the list for create/open modes
    if mode_has_opener "$mode"; then
        local opener_line
        opener_line=$(build_opener_header "$opener_idx")
        fzf_opts+=(--preview="echo '$opener_line'" --preview-window=bottom,1,border-top)
    fi

    # Add tab formatting for claude mode
    if [[ "$mode" == "claude" ]]; then
        fzf_opts+=(--delimiter=$'\t' --tabstop=4)
    fi

    # Handle empty data for non-create modes
    if [[ -z "$data" && "$mode" == "claude" ]]; then
        echo "(no sessions available)" | fzf "${fzf_opts[@]}" 2>/dev/null || true
    elif [[ -z "$data" && "$mode" != "create" ]]; then
        # Show placeholder but keep navigation working
        echo "(no worktrees - use CREATE mode)" | fzf "${fzf_opts[@]}" 2>/dev/null || true
    elif [[ -z "$data" ]]; then
        # Create mode with no data - still allow typing
        echo "" | fzf "${fzf_opts[@]}" 2>/dev/null || true
    else
        echo "$data" | fzf "${fzf_opts[@]}" 2>/dev/null || true
    fi
}

# Parse fzf output
# Returns: query, key, selection (newline separated)
parse_fzf_output() {
    local output="$1"
    echo "$output"
}

# Execute action based on mode and selection
execute_action() {
    local mode="$1"
    local selection="$2"
    local opener="${3:-}"

    if [[ -z "$selection" || "$selection" == "(no worktrees - use CREATE mode)" || "$selection" == "(no sessions available)" ]]; then
        return 1
    fi

    case "$mode" in
        create)
            if [[ -n "$opener" ]]; then
                "$WORKTREE_CMD" create "$selection" -o "$opener"
            else
                "$WORKTREE_CMD" create "$selection"
            fi
            ;;
        open)
            if [[ -n "$opener" ]]; then
                "$WORKTREE_CMD" open "$selection" -o "$opener"
            else
                "$WORKTREE_CMD" open "$selection"
            fi
            ;;
        checkout)
            "$WORKTREE_CMD" checkout "$selection"
            ;;
        delete)
            # Delete needs terminal interaction for confirmation
            "$WORKTREE_CMD" delete "$selection"
            ;;
        claude)
            local session_id
            session_id=$(echo "$selection" | cut -f1)
            "$WORKTREE_CMD" claude copy-session "$session_id"
            ;;
    esac
}

# Main loop
main() {
    check_deps

    local mode="${1:-}"
    local opener_idx=0  # Default to first opener (claude)

    # Validate initial mode if provided
    if [[ -n "$mode" ]]; then
        local valid_mode=false
        for m in "${MODES[@]}"; do
            if [[ "$m" == "$mode" ]]; then
                valid_mode=true
                break
            fi
        done
        if [[ "$valid_mode" == "false" ]]; then
            mode=""
        fi
    fi

    # Default mode: create if no worktrees, otherwise open
    if [[ -z "$mode" ]]; then
        if has_worktrees; then
            mode="open"
        else
            mode="create"
        fi
    fi

    while true; do
        local data
        data=$(get_data "$mode")

        local result
        result=$(run_fzf "$mode" "$data" "$opener_idx")

        # Parse result (query on line 1, key on line 2, selection on line 3)
        local query key selection
        query=$(echo "$result" | sed -n '1p')
        key=$(echo "$result" | sed -n '2p')
        selection=$(echo "$result" | sed -n '3p')

        case "$key" in
            left|alt-h)
                mode=$(switch_mode "$mode" "left")
                ;;
            right|alt-l)
                mode=$(switch_mode "$mode" "right")
                ;;
            ctrl-left|ctrl-alt-backspace)
                if mode_has_opener "$mode"; then
                    opener_idx=$(switch_opener "$opener_idx" "left")
                fi
                ;;
            ctrl-right|ctrl-alt-l)
                if mode_has_opener "$mode"; then
                    opener_idx=$(switch_opener "$opener_idx" "right")
                fi
                ;;
            esc)
                exit 0
                ;;
            *)
                # Enter was pressed - resolve opener for create/open
                local current_opener=""
                if mode_has_opener "$mode"; then
                    current_opener="${OPENERS[$opener_idx]}"
                fi

                # For create mode, prefer selection, fall back to query
                if [[ "$mode" == "create" ]]; then
                    if [[ -n "$selection" ]]; then
                        execute_action "$mode" "$selection" "$current_opener"
                    elif [[ -n "$query" ]]; then
                        execute_action "$mode" "$query" "$current_opener"
                    fi
                else
                    if [[ -n "$selection" ]]; then
                        execute_action "$mode" "$selection" "$current_opener"
                    fi
                fi
                exit 0
                ;;
        esac
    done
}

main "$@"
